#include <iostream>
#include <fstream>
#include "tinyply.h"

struct float3 {
    float x, y, z;
};
struct uint3 {
    uint32_t x, y, z;
};

void write_ply_file(const std::string &filepath, std::vector<float3> verts, std::vector<float3> nors,
                    std::vector<uint3> tris) {
    std::filebuf fb_binary;
    fb_binary.open(filepath + "-binary.ply", std::ios::out | std::ios::binary);
    std::ostream outstream_binary(&fb_binary);
    if (outstream_binary.fail()) throw std::runtime_error("failed to open " + filepath);

    tinyply::PlyFile write_file;

    write_file.add_properties_to_element("vertex", {"x", "y", "z"}, tinyply::Type::FLOAT32,
                                         verts.size(), reinterpret_cast<uint8_t *>(verts.data()),
                                         tinyply::Type::INVALID, 0);
    write_file.add_properties_to_element("vertex", {"nx", "ny", "nz"}, tinyply::Type::FLOAT32,
                                         nors.size(), reinterpret_cast<uint8_t *>(nors.data()), tinyply::Type::INVALID,
                                         0);
    if (!tris.empty()) {
        write_file.add_properties_to_element("vertex", {"vertex_indices"}, tinyply::Type::UINT32,
                                             tris.size(), reinterpret_cast<uint8_t *>(tris.data()),
                                             tinyply::Type::UINT8, 3);
    }

    write_file.get_comments().push_back("generated by MagicXin with tinyply 2.3");

    write_file.write(outstream_binary, true);
    std::cout << "\tWrite finished!" << std::endl;
}

void read_ply_file(const std::string &filepath) {
    try {
        std::ifstream ss(filepath);
        if (ss.fail()) {
            throw std::runtime_error("Failed to open: " + filepath);
        }

        tinyply::PlyFile file;
        file.parse_header(ss);

        std::shared_ptr<tinyply::PlyData> vertices, normals, faces;

        try {
            vertices = file.request_properties_from_element("vertex", {"x", "y", "z"});
            normals = file.request_properties_from_element("vertex", {"nx", "ny", "nz"});
            faces = file.request_properties_from_element("face", {"vertex_indices"}, 3);
        }
        catch (const std::exception &e) {
            std::cerr << "tinyply exception: " << e.what() << std::endl;
        }

        file.read(ss);

        if (vertices) std::cout << "\tRead " << vertices->count << " total vertices " << std::endl;
        if (normals) std::cout << "\tRead " << normals->count << " total vertex normals " << std::endl;
        if (faces) std::cout << "\tRead " << faces->count << " total faces (triangles) " << std::endl;

        const size_t numVerticesBytes = vertices->buffer.size_bytes();
        std::vector<float3> verts(vertices->count);
        std::memcpy(verts.data(), vertices->buffer.get(), numVerticesBytes);

        const size_t numNormalsBytes = normals->buffer.size_bytes();
        std::vector<float3> nors(normals->count);
        std::memcpy(nors.data(), normals->buffer.get(), numNormalsBytes);

        const size_t numFacesBytes = faces->buffer.size_bytes();
        std::vector<uint3> tris(faces->count);
        std::memcpy(tris.data(), faces->buffer.get(), numFacesBytes);

        write_ply_file(filepath, verts, nors, tris);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught exception: " << e.what() << std::endl;
    }
}

int main(int argc, char *argv[]) {
    read_ply_file(argv[1]);
    return 0;
}
